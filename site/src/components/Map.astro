---

---

<div id="map-container" style="height: 100vh"></div>

<script>
	import { MapboxOverlay as DeckOverlay } from "@deck.gl/mapbox";
	import { ScatterplotLayer } from "@deck.gl/layers";
	import GL from "@luma.gl/constants";
	import mapboxgl from "mapbox-gl";
	import MapboxGeocoder from "@mapbox/mapbox-gl-geocoder";

	// Mapbox Access Token and Style
	const MAPBOX_TOKEN = import.meta.env.PUBLIC_MAPBOX_TOKEN;
	const MAPBOX_STYLE = "mapbox://styles/mapbox/dark-v11";

	// Initialize the map
	export const map = new mapboxgl.Map({
		container: "map-container",
		style: MAPBOX_STYLE,
		center: [35.3027, 31.9466],
		zoom: 7.5,
		projection: {
			name: "mercator",
		},
		accessToken: MAPBOX_TOKEN,
	});

	// Function to determine color based on data
	const getColor = (d) => {
		const colors = {
			Right: [59, 130, 246],
			Left: [239, 68, 68],
			"Secular Centre": [234, 179, 8],
			Orthodox: [249, 115, 22],
			"Arab-Israeli": [34, 197, 94],
			Micro: [168, 85, 247],
		};
		// Sum the values of the parties inside each bloc
		const blocSums = Object.entries(d.parties).reduce(
			(acc, [bloc, parties]) => {
				acc[bloc] = Object.values(parties).reduce(
					(sum, value) => sum + value,
					0
				);
				return acc;
			},
			{}
		);
		// Find the bloc with the highest sum
		const maxBloc = Object.keys(blocSums).reduce((a, b) =>
			blocSums[a] > blocSums[b] ? a : b
		);
		return [...colors[maxBloc], 100];
	};

	const updateMapCursor = (cursorStyle) => {
		const canvasContainer = document.querySelector(
			".mapboxgl-canvas-container"
		);
		if (canvasContainer instanceof HTMLElement) {
			canvasContainer.style.cursor = cursorStyle;
		}
	};

	let lastHoveredObject = null;

	// Function to create the ScatterplotLayer
	function createScatterplotLayer(hoveredObject, pointsData) {
		return new ScatterplotLayer({
			id: "points-layer",
			data: pointsData,
			getPosition: (d) => d.pos,
			getFillColor: (d) => {
				if (hoveredObject === d) {
					return getColor(d).map((c) => Math.min(c + 60, 255));
				}
				return getColor(d);
			},
			getRadius: (d) => (hoveredObject === d ? 700 : 500),
			pickable: true,
			onHover: ({ object }) => {
				if (object !== lastHoveredObject) {
					lastHoveredObject = object;
					const newLayers = [
						createScatterplotLayer(object, pointsData),
					];
					deck.setProps({ layers: newLayers });
					if (object) {
						updateMapCursor("crosshair");
						window.updateChartData(object);
					} else {
						updateMapCursor("grab");
					}
				}
			},
			parameters: {
				[GL.DEPTH_TEST]: false,
				[GL.BLEND]: true,
				[GL.BLEND_SRC_RGB]: GL.SRC_ALPHA,
				[GL.BLEND_DST_RGB]: GL.ONE_MINUS_SRC_ALPHA,
				[GL.BLEND_EQUATION]: GL.FUNC_ADD,
			},
			updateTriggers: {
				getFillColor: [hoveredObject],
				getRadius: [hoveredObject],
			},
		});
	}

	// Initial layer setup
	const initialLayers = [createScatterplotLayer(null, [])];
	const deck = new DeckOverlay({
		layers: initialLayers,
	});

	// Add geocoder/search box
	const geocoder = new MapboxGeocoder({
		accessToken: MAPBOX_TOKEN,
		mapboxgl: mapboxgl,
	});

	const geocoderElement = document.getElementById("geocoder");
	if (geocoderElement) {
		geocoderElement.appendChild(geocoder.onAdd(map));
	}

	// Function to load new data based on the selected Knesset
	window.loadNewData = async function () {
		const selector = document.getElementById(
			"json-selector"
		) as HTMLSelectElement;
		const selectedKnesset = selector.value;

		try {
			const dataModule = await import(
				`../points/${selectedKnesset}.json`
			);
			const data = dataModule.default;

			const newLayers = [createScatterplotLayer(null, data)];
			deck.setProps({ layers: newLayers });
		} catch (error) {
			console.error("Error loading data:", error);
		}
	};

	window.loadNewData();

	map.addControl(deck);
</script>
